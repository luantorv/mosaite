import subprocess
import sys
import json
import os
from pathlib import Path
from typing import Optional, Dict, Tuple

# Importamos desde nuestro módulo de constantes
from .constants import (
    ENV_FILE, CONFIG_FILE, REQUIRED_VERSIONS,
    IS_WINDOWS, IS_LINUX, IS_MAC, PROJECT_ROOT
)

def get_os_name():
    """Retorna el nombre del sistema operativo"""
    if IS_WINDOWS: return "windows"
    elif IS_LINUX: return "linux"
    elif IS_MAC: return "macos"
    return "unknown"


class EnvManager:
    """Maneja el archivo .env del proyecto"""
    
    def __init__(self):
        self.env_file = ENV_FILE
        self.env_vars = self._load_env()
    
    def _load_env(self) -> Dict[str, str]:
        # ... (Pega el código de _load_env sin cambios)
        env_vars = {}
        if self.env_file.exists():
            with open(self.env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        env_vars[key.strip()] = value.strip()
        return env_vars
    
    def save(self):
        # ... (Pega el código de save sin cambios)
        with open(self.env_file, 'w') as f:
            f.write("# Mosaite Project Environment Configuration\n")
            f.write("# This file is auto-generated by the setup tool\n\n")
            for key, value in self.env_vars.items():
                f.write(f"{key}={value}\n")
    
    def get(self, key: str, default: str = "") -> str:
        # ... (Pega el código de get sin cambios)
        return self.env_vars.get(key, default)
    
    def set(self, key: str, value: str):
        # ... (Pega el código de set sin cambios)
        self.env_vars[key] = value
        os.environ[key] = value
    
    def is_installed(self) -> bool:
        # ... (Pega el código de is_installed sin cambios)
        return self.get("PROJECT_INSTALLED", "false").lower() == "true"
    
    def mark_installed(self):
        # ... (Pega el código de mark_installed sin cambios)
        self.set("PROJECT_INSTALLED", "true")
        self.set("PROJECT_ROOT", str(PROJECT_ROOT))
        self.set("OS_TYPE", get_os_name())
        self.save()


class ProjectConfig:
    """Maneja la configuración del proyecto (JSON)"""
    
    def __init__(self):
        self.config_path = CONFIG_FILE
        self.config = self._load_config()
        self.env_manager = EnvManager()
    
    def _load_config(self) -> Dict:
        # ... (Pega el código de _load_config sin cambios)
        if self.config_path.exists():
            with open(self.config_path, 'r') as f:
                return json.load(f)
        return {
            "environments": {},
            "current_env": None,
            "setup_completed": False
        }
    
    def save(self):
        # ... (Pega el código de save sin cambios)
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def add_environment(self, name: str, data_path: str):
        # ... (Pega el código de add_environment sin cambios)
        self.config["environments"][name] = {
            "data_path": data_path,
            "db_path": str(Path(data_path) / "db.sqlite3"),
            "pdf_path": str(Path(data_path) / "pdfs")
        }
        if not self.config["current_env"]:
            self.config["current_env"] = name
        self.save()
    
    def set_current_env(self, name: str):
        # ... (Pega el código de set_current_env sin cambios)
        if name in self.config["environments"]:
            self.config["current_env"] = name
            self.save()
            # Actualizar variables de entorno en el proceso actual
            env = self.config["environments"][name]
            os.environ["PROJECT_DATA_ENV"] = name
            os.environ["DATABASE_PATH"] = env["db_path"]
            os.environ["PDF_PATH"] = env["pdf_path"]
    
    def get_current_env(self) -> Optional[Dict]:
        # ... (Pega el código de get_current_env sin cambios)
        env_name = self.config.get("current_env")
        if env_name:
            return self.config["environments"].get(env_name)
        return None
    
    def mark_setup_completed(self):
        # ... (Pega el código de mark_setup_completed sin cambios)
        self.config["setup_completed"] = True
        self.env_manager.mark_installed()
        self.save()

    def delete_environment(self, name: str) -> bool:
        # ... (Pega el código de delete_environment sin cambios)
        if name in self.config["environments"]:
            del self.config["environments"][name]
            if self.config["current_env"] == name:
                self.config["current_env"] = None
                if "PROJECT_DATA_ENV" in os.environ: del os.environ["PROJECT_DATA_ENV"]
                if "DATABASE_PATH" in os.environ: del os.environ["DATABASE_PATH"]
                if "PDF_PATH" in os.environ: del os.environ["PDF_PATH"]
            self.save()
            return True
        return False

    def rename_environment(self, old_name: str, new_name: str) -> bool:
        # ... (Pega el código de rename_environment sin cambios)
        if new_name in self.config["environments"]:
            return False
        if old_name in self.config["environments"]:
            self.config["environments"][new_name] = self.config["environments"].pop(old_name)
            if self.config["current_env"] == old_name:
                self.config["current_env"] = new_name
                self.set_current_env(new_name) 
            self.save()
            return True
        return False


class DependencyChecker:
    """Verifica las dependencias del sistema"""
    
    @staticmethod
    def check_python() -> Tuple[bool, str, str]:
        # ... (Pega el código de check_python sin cambios)
        current_ver_tuple = (sys.version_info.major, sys.version_info.minor, sys.version_info.micro)
        current_ver_str = f"{current_ver_tuple[0]}.{current_ver_tuple[1]}.{current_ver_tuple[2]}"
        req_ver_str = REQUIRED_VERSIONS["python"]
        try:
            req_ver_tuple = tuple(map(int, req_ver_str.split('.')))
        except ValueError:
            return False, current_ver_str, f"inválida: {req_ver_str}"
        is_correct = current_ver_tuple >= req_ver_tuple
        return is_correct, current_ver_str, f">= {req_ver_str}"
    
    @staticmethod
    def check_nodejs() -> Tuple[bool, str, str]:
        # ... (Pega el código de check_nodejs sin cambios)
        try:
            result = subprocess.run(
                ["node", "--version"],
                capture_output=True,
                text=True
            )
            version = result.stdout.strip().replace("v", "")
            is_correct = version.startswith(REQUIRED_VERSIONS["nodejs"].split('.')[0])
            return is_correct, version, REQUIRED_VERSIONS["nodejs"]
        except FileNotFoundError:
            return False, "Not found", REQUIRED_VERSIONS["nodejs"]
    
    @staticmethod
    def check_texlive() -> Tuple[bool, str, str]:
        # ... (Pega el código de check_texlive sin cambios)
        try:
            result = subprocess.run(
                ["pdflatex", "--version"],
                capture_output=True,
                text=True
            )
            for line in result.stdout.split("\n"):
                if "pdfTeX" in line and REQUIRED_VERSIONS["texlive"] in line:
                    return True, f"pdfTeX {REQUIRED_VERSIONS['texlive']}", REQUIRED_VERSIONS["texlive"]
            return False, "Versión Desconocida", REQUIRED_VERSIONS["texlive"]
        except FileNotFoundError:
            return False, "Not found", REQUIRED_VERSIONS["texlive"]